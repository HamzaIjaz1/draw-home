{
  "version": 3,
  "sources": ["../../../../../node_modules/react-compare-slider/src/ReactCompareSlider.tsx", "../../../../../node_modules/react-compare-slider/src/Container.tsx", "../../../../../node_modules/react-compare-slider/src/ReactCompareSliderHandle.tsx", "../../../../../node_modules/react-compare-slider/src/types.ts", "../../../../../node_modules/react-compare-slider/src/utils.ts", "../../../../../node_modules/react-compare-slider/src/ReactCompareSliderImage.tsx", "../../../../../node_modules/react-compare-slider/src/useReactCompareSliderRef.ts"],
  "sourcesContent": ["import React, {\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport type { CSSProperties, ReactElement } from 'react';\n\nimport { ContainerHandle, ContainerItem } from './Container';\nimport { ReactCompareSliderHandle } from './ReactCompareSliderHandle';\nimport {\n  ReactCompareSliderClipOption,\n  type ReactCompareSliderDetailedProps,\n  type UseReactCompareSliderRefReturn,\n} from './types';\nimport type { UseResizeObserverHandlerProps } from './utils';\nimport { usePrevious } from './utils';\nimport { KeyboardEventKeys, useEventListener, useResizeObserver } from './utils';\n\n/** Properties for internal `updateInternalPosition` callback. */\ninterface UpdateInternalPositionProps {\n  /** X coordinate to update to (landscape). */\n  x: number;\n  /** Y coordinate to update to (portrait). */\n  y: number;\n  /** Whether to calculate using page X and Y offsets (required for pointer events). */\n  isOffset?: boolean;\n}\n\nconst EVENT_PASSIVE_PARAMS = { capture: false, passive: true };\nconst EVENT_CAPTURE_PARAMS = { capture: true, passive: false };\n\n/**\n * Handler for the `handle` container element.\n */\nconst handleContainerClick = (ev: PointerEvent): void => {\n  ev.preventDefault();\n  (ev.currentTarget as HTMLButtonElement).focus();\n};\n\n/** Root Comparison slider. */\nexport const ReactCompareSlider = forwardRef<\n  UseReactCompareSliderRefReturn,\n  ReactCompareSliderDetailedProps\n>(\n  (\n    {\n      boundsPadding = 0,\n      browsingContext = globalThis,\n      changePositionOnHover = false,\n      clip = ReactCompareSliderClipOption.both,\n      disabled = false,\n      handle,\n      itemOne,\n      itemTwo,\n      keyboardIncrement = '5%',\n      onlyHandleDraggable = false,\n      onPositionChange,\n      portrait = false,\n      position = 50,\n      style,\n      transition,\n      ...props\n    },\n    ref,\n  ): ReactElement => {\n    /** DOM node of the root element. */\n    const rootContainerRef = useRef<HTMLDivElement>(null);\n    /** DOM node `itemOne` container. */\n    const clipContainerOneRef = useRef<HTMLDivElement>(null);\n    /** DOM node of `itemTwo`. */\n    const clipContainerTwoRef = useRef<HTMLDivElement>(null);\n    /** DOM node of the handle container. */\n    const handleContainerRef = useRef<HTMLButtonElement>(null);\n    /** Current position as a percentage value (initially negative to sync bounds on mount). */\n    const internalPosition = useRef(position);\n    /** Whether user is currently dragging. */\n    const [isDragging, setIsDragging] = useState(false);\n    /** Whether the `transition` property can be applied. */\n    const [canTransition, setCanTransition] = useState(true);\n    /** Whether component has a `window` event binding. */\n    const hasBrowsingContextBinding = useRef(false);\n    /** Target container for pointer events. */\n    const [interactiveTarget, setInteractiveTarget] = useState<HTMLElement | null>();\n    /** The `position` value at *previous* render. */\n    const previousPosition = usePrevious(position);\n\n    /** Sync the internal position and trigger position change callback if defined. */\n    const updateInternalPosition = useCallback(\n      function updateInternal({ x, y, isOffset }: UpdateInternalPositionProps) {\n        const rootElement = rootContainerRef.current as HTMLDivElement;\n        const handleElement = handleContainerRef.current as HTMLButtonElement;\n        const clipElementOne = clipContainerOneRef.current as HTMLDivElement;\n        const clipElementTwo = clipContainerTwoRef.current as HTMLDivElement;\n        const { width, height, left, top } = rootElement.getBoundingClientRect();\n\n        // Early out when component has zero bounds.\n        if (width === 0 || height === 0) {\n          return;\n        }\n\n        const pixelPosition = portrait\n          ? isOffset\n            ? y - top - browsingContext.scrollY\n            : y\n          : isOffset\n          ? x - left - browsingContext.scrollX\n          : x;\n\n        /** Next position as percentage. */\n        const nextPosition = Math.min(\n          Math.max((pixelPosition / (portrait ? height : width)) * 100, 0),\n          100,\n        );\n\n        const zoomScale = portrait\n          ? height / (rootElement.offsetHeight || 1)\n          : width / (rootElement.offsetWidth || 1);\n\n        const boundsPaddingPercentage =\n          ((boundsPadding * zoomScale) / (portrait ? height : width)) * 100;\n\n        const nextPositionWithBoundsPadding = Math.min(\n          Math.max(nextPosition, boundsPaddingPercentage * zoomScale),\n          100 - boundsPaddingPercentage * zoomScale,\n        );\n\n        internalPosition.current = nextPosition;\n        handleElement.setAttribute('aria-valuenow', `${Math.round(internalPosition.current)}`);\n        handleElement.style.top = portrait ? `${nextPositionWithBoundsPadding}%` : '0';\n        handleElement.style.left = portrait ? '0' : `${nextPositionWithBoundsPadding}%`;\n\n        const clipBoth = clip === ReactCompareSliderClipOption.both;\n\n        if (clipBoth || clip === ReactCompareSliderClipOption.itemOne) {\n          clipElementOne.style.clipPath = portrait\n            ? `inset(0 0 ${100 - nextPositionWithBoundsPadding}% 0)`\n            : `inset(0 ${100 - nextPositionWithBoundsPadding}% 0 0)`;\n        } else {\n          clipElementOne.style.clipPath = 'none';\n        }\n\n        if (clipBoth || clip === ReactCompareSliderClipOption.itemTwo) {\n          clipElementTwo.style.clipPath = portrait\n            ? `inset(${nextPositionWithBoundsPadding}% 0 0 0)`\n            : `inset(0 0 0 ${nextPositionWithBoundsPadding}%)`;\n        } else {\n          clipElementTwo.style.clipPath = 'none';\n        }\n\n        if (onPositionChange) {\n          onPositionChange(internalPosition.current);\n        }\n      },\n      [browsingContext, boundsPadding, clip, onPositionChange, portrait],\n    );\n\n    // Update internal position when other user controllable props change.\n    useEffect(() => {\n      const { width, height } = (\n        rootContainerRef.current as HTMLDivElement\n      ).getBoundingClientRect();\n\n      // Use current internal position if `position` hasn't changed.\n      const nextPosition = position === previousPosition ? internalPosition.current : position;\n\n      updateInternalPosition({\n        x: (width / 100) * nextPosition,\n        y: (height / 100) * nextPosition,\n      });\n    }, [boundsPadding, clip, position, portrait, previousPosition, updateInternalPosition]);\n\n    /** Handle mouse/touch down. */\n    const handlePointerDown = useCallback(\n      (ev: PointerEvent) => {\n        ev.preventDefault();\n\n        // Only handle left mouse button (touch events also use 0).\n        if (disabled || ev.button !== 0) return;\n\n        updateInternalPosition({ isOffset: true, x: ev.pageX, y: ev.pageY });\n        setIsDragging(true);\n        setCanTransition(true);\n      },\n      [disabled, updateInternalPosition],\n    );\n\n    /** Handle mouse/touch move. */\n    const handlePointerMove = useCallback(\n      function moveCall(ev: PointerEvent) {\n        updateInternalPosition({ isOffset: true, x: ev.pageX, y: ev.pageY });\n        setCanTransition(false);\n      },\n      [updateInternalPosition],\n    );\n\n    /** Handle mouse/touch up. */\n    const handlePointerUp = useCallback(() => {\n      setIsDragging(false);\n      setCanTransition(true);\n    }, []);\n\n    const handleTouchEnd = useCallback(() => {\n      setIsDragging(false);\n      setCanTransition(true);\n    }, []);\n\n    /** Resync internal position on resize. */\n    const handleResize: (resizeProps: UseResizeObserverHandlerProps) => void = useCallback(\n      ({ width, height }) => {\n        const { width: scaledWidth, height: scaledHeight } = (\n          rootContainerRef.current as HTMLDivElement\n        ).getBoundingClientRect();\n\n        updateInternalPosition({\n          x: ((width / 100) * internalPosition.current * scaledWidth) / width,\n          y: ((height / 100) * internalPosition.current * scaledHeight) / height,\n        });\n      },\n      [updateInternalPosition],\n    );\n\n    /** Handle keyboard movment. */\n    const handleKeydown = useCallback(\n      (ev: KeyboardEvent) => {\n        if (!Object.values(KeyboardEventKeys).includes(ev.key as KeyboardEventKeys)) {\n          return;\n        }\n\n        ev.preventDefault();\n        setCanTransition(true);\n\n        const { top, left } = (\n          handleContainerRef.current as HTMLButtonElement\n        ).getBoundingClientRect();\n\n        const { width, height } = (\n          rootContainerRef.current as HTMLDivElement\n        ).getBoundingClientRect();\n\n        const isPercentage = typeof keyboardIncrement === 'string';\n        const incrementPercentage = isPercentage\n          ? parseFloat(keyboardIncrement)\n          : (keyboardIncrement / width) * 100;\n\n        const isIncrement = portrait\n          ? ev.key === KeyboardEventKeys.ARROW_LEFT || ev.key === KeyboardEventKeys.ARROW_DOWN\n          : ev.key === KeyboardEventKeys.ARROW_RIGHT || ev.key === KeyboardEventKeys.ARROW_UP;\n\n        const nextPosition = Math.min(\n          Math.max(\n            isIncrement\n              ? internalPosition.current + incrementPercentage\n              : internalPosition.current - incrementPercentage,\n            0,\n          ),\n          100,\n        );\n\n        updateInternalPosition({\n          x: portrait ? left : (width * nextPosition) / 100,\n          y: portrait ? (height * nextPosition) / 100 : top,\n        });\n      },\n      [keyboardIncrement, portrait, updateInternalPosition],\n    );\n\n    // Set target container for pointer events.\n    useEffect(() => {\n      setInteractiveTarget(\n        onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current,\n      );\n    }, [onlyHandleDraggable]);\n\n    // Handle hover events on the container.\n    useEffect(() => {\n      const containerRef = rootContainerRef.current as HTMLDivElement;\n\n      const handlePointerLeave = (): void => {\n        if (isDragging) return;\n        handlePointerUp();\n      };\n\n      if (changePositionOnHover) {\n        containerRef.addEventListener('pointermove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n        containerRef.addEventListener('pointerleave', handlePointerLeave, EVENT_PASSIVE_PARAMS);\n      }\n\n      return () => {\n        containerRef.removeEventListener('pointermove', handlePointerMove);\n        containerRef.removeEventListener('pointerleave', handlePointerLeave);\n      };\n    }, [changePositionOnHover, handlePointerMove, handlePointerUp, isDragging]);\n\n    // Allow drag outside of container while pointer is still down.\n    useEffect(() => {\n      if (isDragging && !hasBrowsingContextBinding.current) {\n        browsingContext.addEventListener('pointermove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n        browsingContext.addEventListener('pointerup', handlePointerUp, EVENT_PASSIVE_PARAMS);\n        hasBrowsingContextBinding.current = true;\n      }\n\n      return (): void => {\n        if (hasBrowsingContextBinding.current) {\n          browsingContext.removeEventListener('pointermove', handlePointerMove);\n          browsingContext.removeEventListener('pointerup', handlePointerUp);\n          hasBrowsingContextBinding.current = false;\n        }\n      };\n    }, [handlePointerMove, handlePointerUp, isDragging, browsingContext]);\n\n    useImperativeHandle(\n      ref,\n      () => {\n        return {\n          rootContainer: rootContainerRef.current,\n          handleContainer: handleContainerRef.current,\n          setPosition(nextPosition): void {\n            const { width, height } = (\n              rootContainerRef.current as HTMLDivElement\n            ).getBoundingClientRect();\n\n            updateInternalPosition({\n              x: (width / 100) * nextPosition,\n              y: (height / 100) * nextPosition,\n            });\n          },\n        };\n      },\n      [updateInternalPosition],\n    );\n\n    // Bind resize observer to container.\n    useResizeObserver(rootContainerRef, handleResize);\n\n    useEventListener(\n      'touchend',\n      handleTouchEnd,\n      interactiveTarget as HTMLDivElement,\n      EVENT_CAPTURE_PARAMS,\n    );\n\n    useEventListener(\n      'keydown',\n      handleKeydown,\n      handleContainerRef.current as HTMLButtonElement,\n      EVENT_CAPTURE_PARAMS,\n    );\n\n    useEventListener(\n      'click',\n      handleContainerClick,\n      handleContainerRef.current as HTMLButtonElement,\n      EVENT_CAPTURE_PARAMS,\n    );\n\n    useEventListener(\n      'pointerdown',\n      handlePointerDown,\n      interactiveTarget as HTMLDivElement,\n      EVENT_CAPTURE_PARAMS,\n    );\n\n    // Use custom handle if requested.\n    const Handle = handle || <ReactCompareSliderHandle disabled={disabled} portrait={portrait} />;\n    const appliedTransition = canTransition ? transition : undefined;\n\n    const rootStyle: CSSProperties = {\n      position: 'relative',\n      display: 'grid',\n      maxWidth: '100%',\n      maxHeight: '100%',\n      overflow: 'hidden',\n      cursor: isDragging ? (portrait ? 'ns-resize' : 'ew-resize') : undefined,\n      touchAction: 'pan-y',\n      userSelect: 'none',\n      KhtmlUserSelect: 'none',\n      msUserSelect: 'none',\n      MozUserSelect: 'none',\n      WebkitUserSelect: 'none',\n      ...style,\n    };\n\n    return (\n      <div {...props} ref={rootContainerRef} style={rootStyle} data-rcs=\"root\">\n        <ContainerItem ref={clipContainerOneRef} transition={appliedTransition}>\n          {itemOne}\n        </ContainerItem>\n\n        <ContainerItem ref={clipContainerTwoRef} transition={appliedTransition}>\n          {itemTwo}\n        </ContainerItem>\n\n        <ContainerHandle\n          disabled={disabled}\n          portrait={portrait}\n          position={Math.round(internalPosition.current)}\n          ref={handleContainerRef}\n          transition={appliedTransition}\n        >\n          {Handle}\n        </ContainerHandle>\n      </div>\n    );\n  },\n);\n\nReactCompareSlider.displayName = 'ReactCompareSlider';\n", "import React, { forwardRef } from 'react';\nimport type { CSSProperties, ComponentPropsWithoutRef, ReactElement } from 'react';\n\nimport type { ReactCompareSliderCommonProps } from './types';\n\ntype ContainerItemProps = ComponentPropsWithoutRef<'div'> &\n  Pick<ReactCompareSliderCommonProps, 'transition'> & {\n    order?: number;\n  };\n\n/** Container for clipped item. */\nexport const ContainerItem = forwardRef<HTMLDivElement, ContainerItemProps>(\n  ({ transition, order, ...props }, ref): ReactElement => {\n    const style: CSSProperties = {\n      gridArea: '1 / 1 / 2 / 2',\n      order,\n      maxWidth: '100%',\n      overflow: 'hidden',\n      boxSizing: 'border-box',\n      transition: transition ? `clip-path ${transition}` : undefined,\n      userSelect: 'none',\n      willChange: 'clip-path, transition',\n      KhtmlUserSelect: 'none',\n      MozUserSelect: 'none',\n      WebkitUserSelect: 'none',\n    };\n\n    return <div {...props} style={style} data-rcs=\"clip-item\" ref={ref} />;\n  },\n);\n\nContainerItem.displayName = 'ContainerItem';\n\ntype ContainerHandleProps = ComponentPropsWithoutRef<'button'> & ReactCompareSliderCommonProps;\n\n/** Container to control the handle's position. */\nexport const ContainerHandle = forwardRef<HTMLButtonElement, ContainerHandleProps>(\n  ({ children, disabled, portrait, position, transition }, ref): ReactElement => {\n    const targetAxis = portrait ? 'top' : 'left';\n\n    const style: CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      width: portrait ? '100%' : undefined,\n      height: portrait ? undefined : '100%',\n      background: 'none',\n      border: 0,\n      padding: 0,\n      pointerEvents: 'all',\n      appearance: 'none',\n      WebkitAppearance: 'none',\n      MozAppearance: 'none',\n      outline: 0,\n      transform: portrait ? `translate3d(0, -50% ,0)` : `translate3d(-50%, 0, 0)`,\n      transition: transition ? `${targetAxis} ${transition}` : undefined,\n    };\n\n    return (\n      <button\n        ref={ref}\n        aria-label=\"Drag to move or focus and use arrow keys\"\n        aria-orientation={portrait ? 'vertical' : 'horizontal'}\n        aria-valuemin={0}\n        aria-valuemax={100}\n        aria-valuenow={position}\n        data-rcs=\"handle-container\"\n        disabled={disabled}\n        role=\"slider\"\n        style={style}\n      >\n        {children}\n      </button>\n    );\n  },\n);\n\nContainerHandle.displayName = 'ThisHandleContainer';\n", "import React from 'react';\nimport type { CSSProperties, FC, HtmlHTMLAttributes, ReactElement } from 'react';\n\nimport type { ReactCompareSliderCommonProps } from './types';\n\ninterface ThisArrowProps {\n  /** Whether to flip the arrow direction. */\n  flip?: boolean;\n}\n\nconst ThisArrow: FC<ThisArrowProps> = ({ flip }) => {\n  const style: CSSProperties = {\n    width: 0,\n    height: 0,\n    borderTop: '8px solid transparent',\n    borderRight: '10px solid',\n    borderBottom: '8px solid transparent',\n    transform: flip ? 'rotate(180deg)' : undefined,\n  };\n\n  return <div className=\"__rcs-handle-arrow\" style={style} />;\n};\n\n/** Props for `ReactCompareSliderHandle`. */\nexport interface ReactCompareSliderHandleProps\n  extends Pick<ReactCompareSliderCommonProps, 'disabled' | 'portrait'> {\n  /** Optional styles for handle the button. */\n  buttonStyle?: CSSProperties;\n  /** Optional styles for lines either side of the handle button. */\n  linesStyle?: CSSProperties;\n  /** Optional styles for the handle root. */\n  style?: CSSProperties;\n}\n\n/** Default `handle`. */\nexport const ReactCompareSliderHandle: FC<\n  ReactCompareSliderHandleProps & HtmlHTMLAttributes<HTMLDivElement>\n> = ({\n  className = '__rcs-handle-root',\n  disabled,\n  buttonStyle,\n  linesStyle,\n  portrait,\n  style,\n  ...props\n}): ReactElement => {\n  const _style: CSSProperties = {\n    display: 'flex',\n    flexDirection: portrait ? 'row' : 'column',\n    placeItems: 'center',\n    height: '100%',\n    cursor: disabled ? 'not-allowed' : portrait ? 'ns-resize' : 'ew-resize',\n    pointerEvents: 'none',\n    color: '#fff',\n    ...style,\n  };\n\n  const _linesStyle: CSSProperties = {\n    flexGrow: 1,\n    height: portrait ? 2 : '100%',\n    width: portrait ? '100%' : 2,\n    backgroundColor: 'currentColor',\n    pointerEvents: 'auto',\n    boxShadow: '0 0 4px rgba(0,0,0,.5)',\n    ...linesStyle,\n  };\n\n  const _buttonStyle: CSSProperties = {\n    display: 'grid',\n    gridAutoFlow: 'column',\n    gap: 8,\n    placeContent: 'center',\n    flexShrink: 0,\n    width: 56,\n    height: 56,\n    borderRadius: '50%',\n    borderStyle: 'solid',\n    borderWidth: 2,\n    pointerEvents: 'auto',\n    backdropFilter: 'blur(7px)',\n    WebkitBackdropFilter: 'blur(7px)', // For Safari.\n    backgroundColor: 'rgba(0, 0, 0, 0.125)',\n    boxShadow: '0 0 4px rgba(0,0,0,.35)',\n    transform: portrait ? 'rotate(90deg)' : undefined,\n    ...buttonStyle,\n  };\n\n  return (\n    <div {...props} className={className} style={_style}>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n      <div className=\"__rcs-handle-button\" style={_buttonStyle}>\n        <ThisArrow />\n        <ThisArrow flip />\n      </div>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n    </div>\n  );\n};\n", "import type { HtmlHTMLAttributes, ReactNode, RefAttributes } from 'react';\n\n/** Slider position property. */\nexport type ReactCompareSliderPropPosition = number;\n\n/** Common props shared between components. */\nexport interface ReactCompareSliderCommonProps {\n  /**\n   * Whether to disable slider movement (items are still interactable).\n   * @default false\n   */\n  disabled?: boolean;\n\n  /**\n   * Whether to use portrait (vertical) orientation.\n   * @default false\n   */\n  portrait?: boolean;\n\n  /**\n   * Divider position.\n   * @default 50\n   */\n  position: ReactCompareSliderPropPosition;\n\n  /**\n   * Shorthand CSS `transition` property to apply to handle movement. The specific CSS property\n   * to transition **must not** be provided.\n   * @example '.5s ease-in-out'\n   */\n  transition?: string;\n}\n\nexport const ReactCompareSliderClipOption = {\n  both: 'both',\n  itemOne: 'itemOne',\n  itemTwo: 'itemTwo',\n} as const;\n\nexport type ReactCompareSliderClip =\n  (typeof ReactCompareSliderClipOption)[keyof typeof ReactCompareSliderClipOption];\n\n/** Slider component props *without* ref return props. */\nexport interface ReactCompareSliderRootProps extends Partial<ReactCompareSliderCommonProps> {\n  /**\n   * Padding in pixels to limit the slideable bounds on the X-axis (landscape) or Y-axis (portrait).\n   * @default 0\n   */\n  boundsPadding?: number;\n\n  /**\n   * Custom browsing context to use instead of the global `window` object.\n   * @default globalThis\n   */\n  browsingContext?: Window;\n\n  /**\n   * Whether the slider should follow the pointer on hover.\n   * @default false\n   */\n  changePositionOnHover?: boolean;\n\n  /**\n   * Whether to clip `itemOne`, `itemTwo` or both items.\n   * @default 'both'\n   */\n  clip?: ReactCompareSliderClip;\n\n  /** Custom handle component. */\n  handle?: ReactNode;\n  /** First item to show. */\n  itemOne: ReactNode;\n  /** Second item to show. */\n  itemTwo: ReactNode;\n\n  /**\n   * Percentage or pixel amount to move when the slider handle is focused and keyboard arrow is pressed.\n   * @default '5%'\n   */\n  keyboardIncrement?: number | `${number}%`;\n\n  /**\n   * Whether to only change position when handle is interacted with (useful for touch devices).\n   * @default false\n   */\n  onlyHandleDraggable?: boolean;\n\n  /** Callback on position change with position as percentage. */\n  onPositionChange?: (position: ReactCompareSliderPropPosition) => void;\n}\n\n/** Properties returned by the `useReactCompareSliderRef` hook. */\nexport type UseReactCompareSliderRefReturn = {\n  /**\n   * DOM node of the root container of the slider.\n   * @NOTE This value is only populated **after** the slider has mounted.\n   */\n  rootContainer: HTMLDivElement | null;\n\n  /**\n   * DOM node of the container of the `handle` component.\n   * @NOTE This value is only populated **after** the slider has mounted.\n   */\n  handleContainer: HTMLButtonElement | null;\n\n  /**\n   * Set the position of the slider as a percentage between `0` and `100`.\n   * Updates the slider position after render without triggering re-renders.\n   * @NOTE This function is only actionable **after** the slider has mounted.\n   */\n  setPosition: (position: ReactCompareSliderPropPosition) => void;\n};\n\n/** Slider component props *with* ref return props. */\nexport type ReactCompareSliderProps = ReactCompareSliderRootProps &\n  RefAttributes<UseReactCompareSliderRefReturn>;\n\n/** `ReactCompareSliderProps` and all valid `div` element props. */\nexport type ReactCompareSliderDetailedProps = ReactCompareSliderProps &\n  HtmlHTMLAttributes<HTMLDivElement>;\n", "import type { CSSProperties, RefObject } from 'react';\nimport { useCallback, useEffect, useLayoutEffect, useRef } from 'react';\n\n/** Keyboard `key` events to trigger slider movement. */\nexport enum KeyboardEventKeys {\n  ARROW_LEFT = 'ArrowLeft',\n  ARROW_RIGHT = 'ArrowRight',\n  ARROW_UP = 'ArrowUp',\n  ARROW_DOWN = 'ArrowDown',\n}\n\n/**\n * Stand-alone CSS utility to make replaced elements (`img`, `video`, etc.) fit their container.\n */\nexport const styleFitContainer = ({\n  boxSizing = 'border-box',\n  objectFit = 'cover',\n  objectPosition = 'center center',\n  ...props\n}: CSSProperties = {}): CSSProperties => ({\n  display: 'block',\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  boxSizing,\n  objectFit,\n  objectPosition,\n  ...props,\n});\n\n/** Store the previous supplied value. */\nexport const usePrevious = <T>(value: T): T => {\n  const ref = useRef<T>(value);\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n};\n\n/**\n * Event listener binding hook.\n * @param eventName      - Event to bind to.\n * @param handler        - Callback handler.\n * @param element        - Element to bind to.\n * @param handlerOptions - Event handler options.\n */\nexport const useEventListener = (\n  eventName: EventListener['name'],\n  handler: EventListener['caller'],\n  element: EventTarget,\n  handlerOptions: AddEventListenerOptions,\n): void => {\n  const savedHandler = useRef<EventListener['caller']>();\n\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    // Make sure element supports addEventListener.\n    if (!(element && element.addEventListener)) return;\n\n    // Create event listener that calls handler function stored in ref.\n    const eventListener: EventListener = (event) =>\n      savedHandler.current && savedHandler.current(event);\n\n    element.addEventListener(eventName, eventListener, handlerOptions);\n\n    return (): void => {\n      element.removeEventListener(eventName, eventListener, handlerOptions);\n    };\n  }, [eventName, element, handlerOptions]);\n};\n\n/**\n * Conditionally use `useLayoutEffect` for client *or* `useEffect` for SSR.\n * @see https://github.com/reduxjs/react-redux/blob/89a86805f2fcf9e8fbd2d1dae345ec791de4a71f/src/utils/useIsomorphicLayoutEffect.ts\n */\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n    ? useLayoutEffect\n    : useEffect;\n\n/** Params passed to `useResizeObserver` `handler` function. */\nexport type UseResizeObserverHandlerProps = DOMRect;\n\n/**\n * Bind resize observer callback to element.\n * @param ref       - Element to bind to.\n * @param handler   - Callback for handling entry's bounding rect.\n */\nexport const useResizeObserver = (\n  ref: RefObject<Element>,\n  handler: (entry: UseResizeObserverHandlerProps) => void,\n): void => {\n  const observer = useRef<ResizeObserver>();\n\n  const observe = useCallback(() => {\n    if (ref.current && observer.current) observer.current.observe(ref.current);\n  }, [ref]);\n\n  // Bind/rebind observer when `handler` changes.\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new ResizeObserver(([entry]) => handler(entry!.contentRect));\n    observe();\n\n    return (): void => {\n      if (observer.current) observer.current.disconnect();\n    };\n  }, [handler, observe]);\n};\n", "import React from 'react';\nimport type { CSSProperties, ImgHTMLAttributes, ReactElement } from 'react';\nimport { forwardRef } from 'react';\n\nimport { styleFitContainer } from './utils';\n\n/** Props for `ReactCompareSliderImage`. */\nexport type ReactCompareSliderImageProps = ImgHTMLAttributes<HTMLImageElement>;\n\n/** `Img` element with defaults from `styleFitContainer` applied. */\nexport const ReactCompareSliderImage = forwardRef<HTMLImageElement, ReactCompareSliderImageProps>(\n  ({ style, ...props }, ref): ReactElement => {\n    const rootStyle: CSSProperties = styleFitContainer(style);\n\n    return <img ref={ref} {...props} style={rootStyle} data-rcs=\"image\" />;\n  },\n);\n\nReactCompareSliderImage.displayName = 'ReactCompareSliderImage';\n", "import type { MutableRefObject } from 'react';\nimport { useRef } from 'react';\n\nimport type { UseReactCompareSliderRefReturn } from './types';\n\n/**\n * Control the position and access or modify the DOM elements of the slider.\n */\nexport const useReactCompareSliderRef = (): MutableRefObject<UseReactCompareSliderRefReturn> =>\n  useRef<UseReactCompareSliderRefReturn>({\n    rootContainer: null,\n    handleContainer: null,\n    setPosition: () =>\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[react-compare-slider] `setPosition` cannot be used until the component has mounted.',\n      ),\n  });\n"],
  "mappings": "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",
  "names": ["import_react", "import_jsx_runtime", "jsx", "KeyboardEventKeys", "forwardRef", "useRef", "useCallback", "useEffect", "jsxs"]
}
