"use client";
import {
  require_jsx_runtime
} from "./chunk-JGA6YVWZ.js";
import {
  require_react
} from "./chunk-YQUJFRB2.js";
import {
  __toESM
} from "./chunk-CEQRFMJQ.js";

// ../../node_modules/react-compare-slider/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var ContainerItem = (0, import_react2.forwardRef)(
  ({ transition, order, ...props }, ref) => {
    const style = {
      gridArea: "1 / 1 / 2 / 2",
      order,
      maxWidth: "100%",
      overflow: "hidden",
      boxSizing: "border-box",
      transition: transition ? `clip-path ${transition}` : void 0,
      userSelect: "none",
      willChange: "clip-path, transition",
      KhtmlUserSelect: "none",
      MozUserSelect: "none",
      WebkitUserSelect: "none"
    };
    return (0, import_jsx_runtime.jsx)("div", { ...props, style, "data-rcs": "clip-item", ref });
  }
);
ContainerItem.displayName = "ContainerItem";
var ContainerHandle = (0, import_react2.forwardRef)(
  ({ children, disabled, portrait, position, transition }, ref) => {
    const targetAxis = portrait ? "top" : "left";
    const style = {
      position: "absolute",
      top: 0,
      width: portrait ? "100%" : void 0,
      height: portrait ? void 0 : "100%",
      background: "none",
      border: 0,
      padding: 0,
      pointerEvents: "all",
      appearance: "none",
      WebkitAppearance: "none",
      MozAppearance: "none",
      outline: 0,
      transform: portrait ? `translate3d(0, -50% ,0)` : `translate3d(-50%, 0, 0)`,
      transition: transition ? `${targetAxis} ${transition}` : void 0
    };
    return (0, import_jsx_runtime.jsx)(
      "button",
      {
        ref,
        "aria-label": "Drag to move or focus and use arrow keys",
        "aria-orientation": portrait ? "vertical" : "horizontal",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": position,
        "data-rcs": "handle-container",
        disabled,
        role: "slider",
        style,
        children
      }
    );
  }
);
ContainerHandle.displayName = "ThisHandleContainer";
var ThisArrow = ({ flip }) => {
  const style = {
    width: 0,
    height: 0,
    borderTop: "8px solid transparent",
    borderRight: "10px solid",
    borderBottom: "8px solid transparent",
    transform: flip ? "rotate(180deg)" : void 0
  };
  return (0, import_jsx_runtime2.jsx)("div", { className: "__rcs-handle-arrow", style });
};
var ReactCompareSliderHandle = ({
  className = "__rcs-handle-root",
  disabled,
  buttonStyle,
  linesStyle,
  portrait,
  style,
  ...props
}) => {
  const _style = {
    display: "flex",
    flexDirection: portrait ? "row" : "column",
    placeItems: "center",
    height: "100%",
    cursor: disabled ? "not-allowed" : portrait ? "ns-resize" : "ew-resize",
    pointerEvents: "none",
    color: "#fff",
    ...style
  };
  const _linesStyle = {
    flexGrow: 1,
    height: portrait ? 2 : "100%",
    width: portrait ? "100%" : 2,
    backgroundColor: "currentColor",
    pointerEvents: "auto",
    boxShadow: "0 0 4px rgba(0,0,0,.5)",
    ...linesStyle
  };
  const _buttonStyle = {
    display: "grid",
    gridAutoFlow: "column",
    gap: 8,
    placeContent: "center",
    flexShrink: 0,
    width: 56,
    height: 56,
    borderRadius: "50%",
    borderStyle: "solid",
    borderWidth: 2,
    pointerEvents: "auto",
    backdropFilter: "blur(7px)",
    WebkitBackdropFilter: "blur(7px)",
    // For Safari.
    backgroundColor: "rgba(0, 0, 0, 0.125)",
    boxShadow: "0 0 4px rgba(0,0,0,.35)",
    transform: portrait ? "rotate(90deg)" : void 0,
    ...buttonStyle
  };
  return (0, import_jsx_runtime2.jsxs)("div", { ...props, className, style: _style, children: [
    (0, import_jsx_runtime2.jsx)("div", { className: "__rcs-handle-line", style: _linesStyle }),
    (0, import_jsx_runtime2.jsxs)("div", { className: "__rcs-handle-button", style: _buttonStyle, children: [
      (0, import_jsx_runtime2.jsx)(ThisArrow, {}),
      (0, import_jsx_runtime2.jsx)(ThisArrow, { flip: true })
    ] }),
    (0, import_jsx_runtime2.jsx)("div", { className: "__rcs-handle-line", style: _linesStyle })
  ] });
};
var ReactCompareSliderClipOption = {
  both: "both",
  itemOne: "itemOne",
  itemTwo: "itemTwo"
};
var KeyboardEventKeys = ((KeyboardEventKeys2) => {
  KeyboardEventKeys2["ARROW_LEFT"] = "ArrowLeft";
  KeyboardEventKeys2["ARROW_RIGHT"] = "ArrowRight";
  KeyboardEventKeys2["ARROW_UP"] = "ArrowUp";
  KeyboardEventKeys2["ARROW_DOWN"] = "ArrowDown";
  return KeyboardEventKeys2;
})(KeyboardEventKeys || {});
var styleFitContainer = ({
  boxSizing = "border-box",
  objectFit = "cover",
  objectPosition = "center center",
  ...props
} = {}) => ({
  display: "block",
  width: "100%",
  height: "100%",
  maxWidth: "100%",
  boxSizing,
  objectFit,
  objectPosition,
  ...props
});
var usePrevious = (value) => {
  const ref = (0, import_react3.useRef)(value);
  (0, import_react3.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
};
var useEventListener = (eventName, handler, element, handlerOptions) => {
  const savedHandler = (0, import_react3.useRef)();
  (0, import_react3.useEffect)(() => {
    savedHandler.current = handler;
  }, [handler]);
  (0, import_react3.useEffect)(() => {
    if (!(element && element.addEventListener))
      return;
    const eventListener = (event) => savedHandler.current && savedHandler.current(event);
    element.addEventListener(eventName, eventListener, handlerOptions);
    return () => {
      element.removeEventListener(eventName, eventListener, handlerOptions);
    };
  }, [eventName, element, handlerOptions]);
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react3.useLayoutEffect : import_react3.useEffect;
var useResizeObserver = (ref, handler) => {
  const observer = (0, import_react3.useRef)();
  const observe = (0, import_react3.useCallback)(() => {
    if (ref.current && observer.current)
      observer.current.observe(ref.current);
  }, [ref]);
  useIsomorphicLayoutEffect(() => {
    observer.current = new ResizeObserver(([entry]) => handler(entry.contentRect));
    observe();
    return () => {
      if (observer.current)
        observer.current.disconnect();
    };
  }, [handler, observe]);
};
var EVENT_PASSIVE_PARAMS = { capture: false, passive: true };
var EVENT_CAPTURE_PARAMS = { capture: true, passive: false };
var handleContainerClick = (ev) => {
  ev.preventDefault();
  ev.currentTarget.focus();
};
var ReactCompareSlider = (0, import_react.forwardRef)(
  ({
    boundsPadding = 0,
    browsingContext = globalThis,
    changePositionOnHover = false,
    clip = ReactCompareSliderClipOption.both,
    disabled = false,
    handle,
    itemOne,
    itemTwo,
    keyboardIncrement = "5%",
    onlyHandleDraggable = false,
    onPositionChange,
    portrait = false,
    position = 50,
    style,
    transition,
    ...props
  }, ref) => {
    const rootContainerRef = (0, import_react.useRef)(null);
    const clipContainerOneRef = (0, import_react.useRef)(null);
    const clipContainerTwoRef = (0, import_react.useRef)(null);
    const handleContainerRef = (0, import_react.useRef)(null);
    const internalPosition = (0, import_react.useRef)(position);
    const [isDragging, setIsDragging] = (0, import_react.useState)(false);
    const [canTransition, setCanTransition] = (0, import_react.useState)(true);
    const hasBrowsingContextBinding = (0, import_react.useRef)(false);
    const [interactiveTarget, setInteractiveTarget] = (0, import_react.useState)();
    const previousPosition = usePrevious(position);
    const updateInternalPosition = (0, import_react.useCallback)(
      function updateInternal({ x, y, isOffset }) {
        const rootElement = rootContainerRef.current;
        const handleElement = handleContainerRef.current;
        const clipElementOne = clipContainerOneRef.current;
        const clipElementTwo = clipContainerTwoRef.current;
        const { width, height, left, top } = rootElement.getBoundingClientRect();
        if (width === 0 || height === 0) {
          return;
        }
        const pixelPosition = portrait ? isOffset ? y - top - browsingContext.scrollY : y : isOffset ? x - left - browsingContext.scrollX : x;
        const nextPosition = Math.min(
          Math.max(pixelPosition / (portrait ? height : width) * 100, 0),
          100
        );
        const zoomScale = portrait ? height / (rootElement.offsetHeight || 1) : width / (rootElement.offsetWidth || 1);
        const boundsPaddingPercentage = boundsPadding * zoomScale / (portrait ? height : width) * 100;
        const nextPositionWithBoundsPadding = Math.min(
          Math.max(nextPosition, boundsPaddingPercentage * zoomScale),
          100 - boundsPaddingPercentage * zoomScale
        );
        internalPosition.current = nextPosition;
        handleElement.setAttribute("aria-valuenow", `${Math.round(internalPosition.current)}`);
        handleElement.style.top = portrait ? `${nextPositionWithBoundsPadding}%` : "0";
        handleElement.style.left = portrait ? "0" : `${nextPositionWithBoundsPadding}%`;
        const clipBoth = clip === ReactCompareSliderClipOption.both;
        if (clipBoth || clip === ReactCompareSliderClipOption.itemOne) {
          clipElementOne.style.clipPath = portrait ? `inset(0 0 ${100 - nextPositionWithBoundsPadding}% 0)` : `inset(0 ${100 - nextPositionWithBoundsPadding}% 0 0)`;
        } else {
          clipElementOne.style.clipPath = "none";
        }
        if (clipBoth || clip === ReactCompareSliderClipOption.itemTwo) {
          clipElementTwo.style.clipPath = portrait ? `inset(${nextPositionWithBoundsPadding}% 0 0 0)` : `inset(0 0 0 ${nextPositionWithBoundsPadding}%)`;
        } else {
          clipElementTwo.style.clipPath = "none";
        }
        if (onPositionChange) {
          onPositionChange(internalPosition.current);
        }
      },
      [browsingContext, boundsPadding, clip, onPositionChange, portrait]
    );
    (0, import_react.useEffect)(() => {
      const { width, height } = rootContainerRef.current.getBoundingClientRect();
      const nextPosition = position === previousPosition ? internalPosition.current : position;
      updateInternalPosition({
        x: width / 100 * nextPosition,
        y: height / 100 * nextPosition
      });
    }, [boundsPadding, clip, position, portrait, previousPosition, updateInternalPosition]);
    const handlePointerDown = (0, import_react.useCallback)(
      (ev) => {
        ev.preventDefault();
        if (disabled || ev.button !== 0)
          return;
        updateInternalPosition({ isOffset: true, x: ev.pageX, y: ev.pageY });
        setIsDragging(true);
        setCanTransition(true);
      },
      [disabled, updateInternalPosition]
    );
    const handlePointerMove = (0, import_react.useCallback)(
      function moveCall(ev) {
        updateInternalPosition({ isOffset: true, x: ev.pageX, y: ev.pageY });
        setCanTransition(false);
      },
      [updateInternalPosition]
    );
    const handlePointerUp = (0, import_react.useCallback)(() => {
      setIsDragging(false);
      setCanTransition(true);
    }, []);
    const handleTouchEnd = (0, import_react.useCallback)(() => {
      setIsDragging(false);
      setCanTransition(true);
    }, []);
    const handleResize = (0, import_react.useCallback)(
      ({ width, height }) => {
        const { width: scaledWidth, height: scaledHeight } = rootContainerRef.current.getBoundingClientRect();
        updateInternalPosition({
          x: width / 100 * internalPosition.current * scaledWidth / width,
          y: height / 100 * internalPosition.current * scaledHeight / height
        });
      },
      [updateInternalPosition]
    );
    const handleKeydown = (0, import_react.useCallback)(
      (ev) => {
        if (!Object.values(KeyboardEventKeys).includes(ev.key)) {
          return;
        }
        ev.preventDefault();
        setCanTransition(true);
        const { top, left } = handleContainerRef.current.getBoundingClientRect();
        const { width, height } = rootContainerRef.current.getBoundingClientRect();
        const isPercentage = typeof keyboardIncrement === "string";
        const incrementPercentage = isPercentage ? parseFloat(keyboardIncrement) : keyboardIncrement / width * 100;
        const isIncrement = portrait ? ev.key === "ArrowLeft" || ev.key === "ArrowDown" : ev.key === "ArrowRight" || ev.key === "ArrowUp";
        const nextPosition = Math.min(
          Math.max(
            isIncrement ? internalPosition.current + incrementPercentage : internalPosition.current - incrementPercentage,
            0
          ),
          100
        );
        updateInternalPosition({
          x: portrait ? left : width * nextPosition / 100,
          y: portrait ? height * nextPosition / 100 : top
        });
      },
      [keyboardIncrement, portrait, updateInternalPosition]
    );
    (0, import_react.useEffect)(() => {
      setInteractiveTarget(
        onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current
      );
    }, [onlyHandleDraggable]);
    (0, import_react.useEffect)(() => {
      const containerRef = rootContainerRef.current;
      const handlePointerLeave = () => {
        if (isDragging)
          return;
        handlePointerUp();
      };
      if (changePositionOnHover) {
        containerRef.addEventListener("pointermove", handlePointerMove, EVENT_PASSIVE_PARAMS);
        containerRef.addEventListener("pointerleave", handlePointerLeave, EVENT_PASSIVE_PARAMS);
      }
      return () => {
        containerRef.removeEventListener("pointermove", handlePointerMove);
        containerRef.removeEventListener("pointerleave", handlePointerLeave);
      };
    }, [changePositionOnHover, handlePointerMove, handlePointerUp, isDragging]);
    (0, import_react.useEffect)(() => {
      if (isDragging && !hasBrowsingContextBinding.current) {
        browsingContext.addEventListener("pointermove", handlePointerMove, EVENT_PASSIVE_PARAMS);
        browsingContext.addEventListener("pointerup", handlePointerUp, EVENT_PASSIVE_PARAMS);
        hasBrowsingContextBinding.current = true;
      }
      return () => {
        if (hasBrowsingContextBinding.current) {
          browsingContext.removeEventListener("pointermove", handlePointerMove);
          browsingContext.removeEventListener("pointerup", handlePointerUp);
          hasBrowsingContextBinding.current = false;
        }
      };
    }, [handlePointerMove, handlePointerUp, isDragging, browsingContext]);
    (0, import_react.useImperativeHandle)(
      ref,
      () => {
        return {
          rootContainer: rootContainerRef.current,
          handleContainer: handleContainerRef.current,
          setPosition(nextPosition) {
            const { width, height } = rootContainerRef.current.getBoundingClientRect();
            updateInternalPosition({
              x: width / 100 * nextPosition,
              y: height / 100 * nextPosition
            });
          }
        };
      },
      [updateInternalPosition]
    );
    useResizeObserver(rootContainerRef, handleResize);
    useEventListener(
      "touchend",
      handleTouchEnd,
      interactiveTarget,
      EVENT_CAPTURE_PARAMS
    );
    useEventListener(
      "keydown",
      handleKeydown,
      handleContainerRef.current,
      EVENT_CAPTURE_PARAMS
    );
    useEventListener(
      "click",
      handleContainerClick,
      handleContainerRef.current,
      EVENT_CAPTURE_PARAMS
    );
    useEventListener(
      "pointerdown",
      handlePointerDown,
      interactiveTarget,
      EVENT_CAPTURE_PARAMS
    );
    const Handle = handle || (0, import_jsx_runtime3.jsx)(ReactCompareSliderHandle, { disabled, portrait });
    const appliedTransition = canTransition ? transition : void 0;
    const rootStyle = {
      position: "relative",
      display: "grid",
      maxWidth: "100%",
      maxHeight: "100%",
      overflow: "hidden",
      cursor: isDragging ? portrait ? "ns-resize" : "ew-resize" : void 0,
      touchAction: "pan-y",
      userSelect: "none",
      KhtmlUserSelect: "none",
      msUserSelect: "none",
      MozUserSelect: "none",
      WebkitUserSelect: "none",
      ...style
    };
    return (0, import_jsx_runtime3.jsxs)("div", { ...props, ref: rootContainerRef, style: rootStyle, "data-rcs": "root", children: [
      (0, import_jsx_runtime3.jsx)(ContainerItem, { ref: clipContainerOneRef, transition: appliedTransition, children: itemOne }),
      (0, import_jsx_runtime3.jsx)(ContainerItem, { ref: clipContainerTwoRef, transition: appliedTransition, children: itemTwo }),
      (0, import_jsx_runtime3.jsx)(
        ContainerHandle,
        {
          disabled,
          portrait,
          position: Math.round(internalPosition.current),
          ref: handleContainerRef,
          transition: appliedTransition,
          children: Handle
        }
      )
    ] });
  }
);
ReactCompareSlider.displayName = "ReactCompareSlider";
var ReactCompareSliderImage = (0, import_react4.forwardRef)(
  ({ style, ...props }, ref) => {
    const rootStyle = styleFitContainer(style);
    return (0, import_jsx_runtime4.jsx)("img", { ref, ...props, style: rootStyle, "data-rcs": "image" });
  }
);
ReactCompareSliderImage.displayName = "ReactCompareSliderImage";
var useReactCompareSliderRef = () => (0, import_react5.useRef)({
  rootContainer: null,
  handleContainer: null,
  setPosition: () => (
    // eslint-disable-next-line no-console
    console.warn(
      "[react-compare-slider] `setPosition` cannot be used until the component has mounted."
    )
  )
});
export {
  ReactCompareSlider,
  ReactCompareSliderClipOption,
  ReactCompareSliderHandle,
  ReactCompareSliderImage,
  styleFitContainer,
  useReactCompareSliderRef
};
//# sourceMappingURL=react-compare-slider.js.map
